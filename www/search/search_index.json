{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to Spry!","text":"<p>Spry borrows homoiconicity from Rebol and Lisp, free form syntax from Forth and Rebol, words of different types from Rebol, good data structure literal support from JavaScript and the general coding experience and style from Smalltalk. It also has a few ideas of its own, like an interesting argument passing mechanism and a relatively novel take on OO.</p> <p>Spry is dynamically typed and while trying to recreate the \"feeling\" of Smalltalk this is an experiment in trying out \"interesting\" approaches.</p> <p>The current reference implementation of Spry is in a few thousand lines of Nim which gives very easy access to C/C++ and Nim eco systems. It also enables native threads and high performance garbage collection. This interpreter is modular and can be compiled statically to around 100kb in size. It can also be compiled to JavaScript, as this REPL here on the website shows.</p> <p>Currently Spry can run as a standalone interpreter called <code>spry</code> (just like Python), as an embedded interpreter in a Nim executable (easy to make single binary programs!) or as an interactive interpreter, a REPL, called <code>ispry</code>.</p> <p>There is a fair bit of example code available including cross platform UI examples. Take a look at Tasting Spry for a sense of the language.</p>"},{"location":"index.html#vision-of-spry","title":"Vision of Spry","text":"<p>My vision of Spry is to support 100% live coding in a Smalltalk style immersive environment, but much more integrated with the various eco systems outside of Spry. Think Smalltalk, but distilled to the core and without the island isolation.</p> <p>I also wish to explore other things with it like simple game development, perhaps aimed primarily at kids but also the live image model in a distributed multi user scenario by using a modern embedded database, cloud and networking technology. Yeah, not entirely super clear but if you know about GemStone/S, try visualize that on a global cloud scale, although simplified in architecture.</p> <p>Join for the fun!</p>"},{"location":"about.html","title":"About Spry","text":"<p>I have always entertained thoughts of making my own programming language. Ever since 1994 I have been an avid Smalltalker and I was for many years very active in the Squeak community. The Smalltalk coding experience and environment is in many ways still completely unmatched.</p> <p>But Alan Kay is right that Smalltalk and Lisp \"tend to eat their young\" which may be a slightly obscure phrase, but I think both these two camps are so comfortable in their respective environments that they have stopped even thinking that things can be improved, that we can still innovate. I think it's about time to move forward!</p> <p>And now that I have found a really fast implementation language that I actually enjoy working in, I started burning in late 2015.</p> <p>The language is called Spry but was initially named Ni (as in the Knights Who Say\u2026), but I decided to rename it. Spry has a good ring to it, it seems fairly nice to google and I managed to catch sprylang.org, but for various reasons ended up with the Swedish TLD instead, sprylang.se.</p> <p>And <code>#sprylang</code> is a good hash for twitter. :)</p>"},{"location":"community.html","title":"Community","text":"<p>We are... eh, not that many yet - so please join! The discord server is the best place to start!</p> <ul> <li>http://sprylang.se - Eh... here.</li> <li>https://discord.gg/mK8HZNd - The Discord server, main place for Spry!</li> <li>https://groups.google.com/forum/#!forum/sprylang - The google group, not really active.</li> <li>http://github.com/gokr/spry - The source Luke!</li> </ul>"},{"location":"community.html#links","title":"Links","text":"<ul> <li>http://goran.krampe.se/category/spry - My articles on Spry on my blog</li> <li>A little article on Ni</li> </ul>"},{"location":"manual.html","title":"Language Manual","text":"<p>IN PROGRESS!!!!</p> <p>Spry code consists solely of comments, literals, words and composites separated by whitespace.</p> <p>In Spry everything is an AST node, hereafter referred to as a node. The parsing step produces an AST (Abstract Syntax Tree) of such nodes from a string of code. This AST fully mirrors the Spry syntax. The nodes can then be evaluated. This means the Spry VM executes the AST directly without compiling it further to bytecodes or native code.</p>"},{"location":"manual.html#comments","title":"Comments","text":"<p>In Spry a comment begins with a <code>#</code> parsed outside literals and consumes the rest of the line. This is the only syntax for comments.</p> <pre><code># Comments can be on their\n# own lines but each line must start with a #\necho \"Hey\" # But they can also begin after code\necho \"Comments begin with # but they can not start inside literals\"\n</code></pre>"},{"location":"manual.html#literals","title":"Literals","text":"<p>Spry has three standard literals; int, float and string. A literal is a specific syntax that the parser can identify and solely from that - create the proper type of node. Te nodes created are \"boxed\" Nim values of the corresponding Nim types <code>int</code>, <code>float</code> and <code>string</code>.</p> <p>It is worth noting that the literal nodes are created during parsing and not during evaluation.</p> <p>Note</p> <p>The Spry VM also supports pluggable literals so you can easily add your own new literals in extra Spry VM modules, there is an example in the module <code>spryextend.nim</code> that adds support for multiline string literals.</p>"},{"location":"manual.html#literal-int","title":"Literal int","text":"<p>An int is signed and its size is platform dependent and has the same size as a pointer. <code>_</code> is allowed inside an integer literal and is ignored, it can make big numbers easier to read like <code>340_000_000</code>. Examples are <code>42</code>, <code>-34</code>, <code>+12</code>.</p>"},{"location":"manual.html#literal-float","title":"Literal float","text":"<p>The size of a float is platform dependent, the Nim compiler chooses the processor's fastest floating point type. The literal syntax supports exponents using either <code>e</code> or <code>E</code> and also ignores any embedded <code>_</code>. Examples are <code>3.14</code>, <code>4e2</code>, <code>-2.734e-3</code> and <code>40.00_001e2</code>.</p>"},{"location":"manual.html#literal-string","title":"Literal string","text":"<p>A string is written using double quotes like <code>\"abc\"</code>. Inside the string we replace any <code>\\\\</code> by <code>\\</code>, any <code>\\'</code> by <code>'</code>, any <code>\\\"</code> by <code>\"</code> and any <code>\\xHH</code> (where <code>HH</code> is a hexadecimal value) with the corresponding ASCII character. All characters are valid inside the string, including newlines. Examples are <code>\"abc\"</code>, <code>\"hey \\\"there\\\"\"</code> and <code>\"abc\\x0Adef\"</code>.</p>"},{"location":"manual.html#words","title":"Words","text":"<p>If it's not a literal, then it's a word. Words are separated from each other using whitespace or any of the composite characters \"<code>()[]{}</code>\". There is also a special set of characters that can only form words together with other characters from the same set (or on their own) - \"<code>,;\\^&amp;%|~</code>\". Of these only <code>,</code>, <code>;</code> and <code>^</code> are current core spry words, the other characters are still unused.</p> <p>Note that a word in Spry can be a single character like <code>=</code> or <code>$</code> or a combination thereof, it doesn't have to be an alphabetic sequence. Words are normally keys bound to values and they are used both as classic \"variables\" but also for naming functions and other constructs in Spry. This is borrowed from Rebol.</p> <p>Note</p> <p>The special characters rule removes some uncomfortable need of whitespace to separate things but you still need whitespace to ensure that words like <code>=</code> and <code>+</code> are properly parsed for code like <code>3 + 4</code> or <code>x = 14</code>. Pull requests to fix this in the parser are welcome :)</p> <p>Words come in different types depending on prefixing characters. The word type dictates the behavior when the word is evaluated:</p> <ol> <li>A Get word is prefixed with <code>$</code>.</li> <li>An Eval word has no prefix. This is the most common word.</li> <li>A Literal word is prefixed with <code>'</code>.</li> </ol> <p>Get and Eval words also come in 5 different variants, totalling 11 different concrete word types.</p> <p>Finally we also have Keywords which is simply a \"syntactical sugar\" in the Spry parser that enables Smalltalk style keyword calls.</p>"},{"location":"manual.html#get-word","title":"Get word","text":"<p>When evaluated, a get word simply performs a lookup using the word itself as the key and the result is the node found. Get words are used when you want to refer to something by name and make sure you only perform the lookup. This way you can refer to for example functions without evaluating them.</p> <p>Note</p> <p>In many other languages you refer to the function itself using it's name like <code>foo</code> and you call the function using a different syntax, for example <code>foo()</code>. In Spry it's the other way around, we call functions simply by their name like <code>foo</code>, but if we want to refer to the function itself without calling it we use <code>$foo</code>.</p> <p>There are different variants:</p> <ol> <li>Regular get word, for example <code>$x</code>. This looks first among local variables (in <code>locals</code>), then outwards lexically.</li> <li>Module qualified get word, for example <code>$Foo::x</code>. This looks directly in the Module named <code>Foo</code> and nowhere else. It's equivalent to <code>Foo at: 'x</code>.</li> <li>Self get word, for example <code>$@x</code>. This looks directly in <code>self</code> and nowhere else. It's equivalent to <code>$self::x</code> or <code>self at: 'x</code>.</li> <li>Outer get word, for example <code>$..x</code>. This is like a regular get word but does not first look in local variables.</li> <li>Arg get word, for example <code>:$x</code>. This pulls in the next argument for the lexically closest outer <code>func</code>, without first evaluating it in the calling scope, and stores it in <code>locals</code> as <code>x</code>. This makes it possible to write \"macro like\" functions.</li> </ol>"},{"location":"manual.html#eval-word","title":"Eval word","text":"<p>An eval word works like a get word, but it also evaluates the result of the lookup. If the result of the lookup is for example a <code>func</code> then it is called. Just like get words we have the same 5 different variants, the difference is only the added evaluation.</p> <ol> <li>Regular eval word, for example <code>x</code>. This looks first in <code>locals</code>, then outwards lexically and then evaluates the result.</li> <li>Module eval word, for example <code>Foo::x</code>. This looks directly in the Module named <code>Foo</code> and nowhere else, and then evaluates the result. It's equivalent to <code>eval (Foo at: 'x)</code>.</li> <li>Self eval word, for example <code>@x</code>. This looks directly in <code>self</code> and nowhere else and then evaluates the result. It's equivalent to <code>self::x</code> or <code>self at: 'x</code>.</li> <li>Outer eval word, for example <code>..x</code>. This is like a regular eval word but does not first look in <code>locals</code>.</li> <li>Arg eval word, for example <code>:x</code>. This pulls in the next argument to the lexically closest outer <code>func</code>, but first evaluates it in the calling scope, and then stores the result in <code>locals</code> as <code>x</code>.</li> </ol>"},{"location":"manual.html#literal-word","title":"Literal word","text":"<p>A literal word is a canonicalized (there is only ever one instance of every unique word) string and is written like <code>'foo</code>. This is very much like a Symbol in Smalltalk or Ruby. Obviously all described words above can be created in literal form just by prepending a <code>'</code>, like <code>'$foo</code>, <code>':foo</code> and so on. A literal word evaluates as itself.</p> <p>You use a literal word when you want to compose code or in situations where you would use a Symbol in Ruby/Smalltalk. Literal words can be reified using <code>reify</code>.</p>"},{"location":"manual.html#keywords","title":"Keywords","text":"<p>The message syntax of Smalltalk has proven itself over many years to be very readable and expressive. In Smalltalk a call (message) that takes arguments is written in \"keyword style\" like <code>'hello' copyFrom: 1 to: 2</code> which roughly in other languages would translate to <code>\"hello\".copy(1, 2)</code> or at best <code>\"hello\".copy(from=1, to=2)</code>. The advantage of the Smalltalk style is that it doesn't make you wonder what the arguments actually denote and in which order they should be given.</p> <p>The name of the method in this example in Smalltalk is <code>copyFrom:to:</code> so the colons are part of the identifier. Spry (unlike Rebol) allows for colons in words just like Smalltalk does and the Spry parser will thus automatically perform a rewrite of <code>\"hello\" copyFrom: 1 to: 2</code> into <code>\"hello\" copyFrom:to: 1 2</code> thus turning the call into a regular infix (first argument to the left) Spry function call, see Functions.</p> <p>Both ways of writing are valid, although the latter would be... very ugly.</p> <p>But before explaining functions and function calls we first need to go through some simpler parts.</p>"},{"location":"manual.html#precedence","title":"Precedence","text":"<p>All programming languages have more or less complicated rules for evaluation precedence in expressions. Rebol and Smalltalk excel with very simple rules, while some other languages have dreadful intricate rules. Rebol and Smalltalk both have a base rule of evaluating from left to right and Spry has the very same rule.</p> <p>Then Smalltalk evaluate unary before binary, and binary before keyword messages. This usually removes a lot of parentheses and is quite natural in Smalltalk. Rebol has something similar where it evaluates operators before functions.</p> <p>But in Spry there is no such additional rules. The rule is simply from left to right. To do anything different you use parentheses!</p> <pre><code>x = (3 + 4)       # Otherwise Spry assigns only 3 to x\ny = (2 + 3 * 4)   # Equals 20\ny = (2 + (3 * 4)) # Equals 14\n</code></pre>"},{"location":"manual.html#booleans","title":"Booleans","text":"<p>There are no literals for booleans (!), but there are two  singleton instances of the VM's internal boolean node type (BoolVal) that are bound to the words <code>true</code> and <code>false</code> in the root namespace. That's a mouthful explaining that yes, you can use <code>true</code> and <code>false</code> pretty much as usual. This design is borrowed from Smalltalk.</p> <pre><code>x = true\ny = false\nx and y then: [echo \"Both are not true\"]\nx or y then: [echo \"But one is true\"]\ny not then: [echo \"Y is not true\"]\ny else: [echo \"Y is not true\"]\n</code></pre>"},{"location":"manual.html#nil-and-undef","title":"Nil and Undef","text":"<p>In the same manner as booleans we also have the word <code>nil</code> bound to the sole instance of the NilVal node type, and <code>undef</code> bound to the sole instance of UndefVal.</p> <p>Spry is experimenting with distinguishing between <code>nil</code> meaning nothing and <code>undef</code> meaning never assigned any value. For any word the value <code>nil</code> is thus a valid value. When a lookup doesn't find any valye for the key and fails you will get <code>undef</code>. If you get <code>nil</code> it means the lookup succeeded and the value in question is in fact <code>nil</code>. There is a primitive method called <code>?</code> that checks if a node is <code>undef</code>.</p> <pre><code>echo x     # prints \"undef\"\necho (x ?) # prints \"false\"\nx = nil\necho (x ?) # prints \"true\"\necho x     # prints \"nil\"\n</code></pre>"},{"location":"manual.html#composites","title":"Composites","text":"<p>Literals and words are the \"atoms\" of Spry but in order to compose both data and code (Spry is homoiconic) we need some kind of \"structures of many\". We have three of these in core Spry - Block, Paren and Curly.</p>"},{"location":"manual.html#block","title":"Block","text":"<p>The Block is the work horse sequential structure in Spry but it is also the unit of code! Compared to Smalltalk one can almost say it does double duty as BlockClosure and OrderedCollection. A Block is formed using <code>[]</code>, for example <code>[1 + 2]</code>. There is no separator needed.</p> <p>When parsed this will create a Block and when evaluated a Block evaluates to itself - in other words, it does nothing.</p> <p>But if we have a Block we can do a lot of things with it explicitly - like evaluating it as code using the <code>do</code> function:</p> <pre><code># Evaluates to 3, try it in ispry\ndo [1 + 2]\n</code></pre> <p>A Block evaluates in its own local closure which means that the activation of the block has its own Map of local bindings. Assignments operate on this Map but it can also be explicitly accessed using the <code>locals</code> primitive. But in Spry we can also manipulate the Block as a sequence:</p> <pre><code># Evaluates to 7\nfoo = [1 + 2]\nfoo at: 0 put: 5\ndo foo\n</code></pre> <p>Note</p> <p>Yes, in Spry we use the same convention as in Nim regarding indexing - first element is at position 0.</p>"},{"location":"manual.html#paren","title":"Paren","text":"<p>In most programming languages parentheses are only used to control evaluation order and do not reify as anything concrete during execution. In Rebol and Spry however, <code>(1 + 2)</code> reify as a Paren when parsed. A Paren is a Composite internally just like a Block is, but when evaluated a Paren evaluates itself as code without creating a new closure and the result is the result of the last expression. It can be used pretty much as parentheses are used traditionally.</p>"},{"location":"manual.html#curly","title":"Curly","text":"<p>The third Composite is the Curly which is written like <code>{a b c}</code>. It reifies as a Curly when parsed, which also is a Composite internally just like a Block. When a Curly is evaluated it evaluates itself like a Block does in its own closure, but the result is the locals Map of the closure. The net effect of that is that we use Curlys to create Maps:</p> <pre><code>map = {x = 50 y = 100}\n</code></pre>"},{"location":"manual.html#map","title":"Map","text":"<p>As mentioned, the Block is the sequential collection in Spry corresponding to OrderedCollection in Smalltalk. The Map corresponds similarly to Dictionary. All nodes in Spry can be used as keys in a Map. Word nodes come in 11 different types, as earlier described, but when used as keys only the actual word itself is used for hash and equality. This means that when used as keys, <code>$foo</code>, <code>foo</code> and <code>:foo</code> (for example) are all equal since only the actual word \"foo\" is used for hash and <code>==</code>. Literal words on the other hand are always different from each other, for example <code>'$foo</code> is different from <code>'foo</code>.</p>"},{"location":"manual.html#root","title":"Root","text":"<p>Spry is similar to Smalltalk in the sense that there is a special Map that holds all globals. In Smalltalk that Dictionary is called <code>Smalltalk</code>, in Spry we call it <code>root</code>.</p> <p>The root Map is created by the Spry interpreter and populated with words referring to primitive functions and known values like <code>true</code>, <code>false</code> etc. Lookups are done through the lexical scopes, which Blocks and Curlys create when evaluated, up to root.</p> <p>If a lookup still fails there is a special Block held in the word <code>modules</code> containing all Modules that we want should participate in global lookups, in the order they are in that block. A Module is just a Map with some extra meta information in it.</p> <p>The interpreter will iterate through the Modules and perform the lookup in each one until finding a hit, or giving up and returning <code>undef</code>. This means Modules will shadow each other depending on their position in the <code>modules</code> block. But you can always refer to names directly using Module getwords <code>Foo::x</code> or simple Map lookups like <code>Foo at: 'x</code>.</p> <p>This design is an experiment in \"modelessness\" since there are no import statements or other mechanisms to modify how lookups are made in a certain part of your source code. At the same time Modules can be loaded and used even if they do contain naming conflicts.</p>"},{"location":"manual.html#functions-and-methods","title":"Functions and Methods","text":"<p>This inevitably brings us to functions, or Funcs as they are called in Spry. Spry is a heavily functional language, in fact, there are no builtin keywords or operators at all in Spry - everything is a function, including such fundamental things as assignment <code>=</code>.</p> <p>Funcs can be written either as \"primitives\" in Nim or in Spry of course. The Spry VM has a bunch of Funcs included internally, most of which are primitives but also some defined in Spry.</p> <p>Then there are VM modules that define more Funcs, again both primitives and Spry funcs. VM Modules are linked into the VM when you build the Spry VM, currently statically but they could be made to load dynamically as .so/.dlls too.</p> <p>Finally Spry also has Modules that are pure Spry.</p>"},{"location":"manual.html#func","title":"Func","text":"<p>Functions are created from Blocks using the <code>func</code> function that takes a Block of code, performs a shallow copy of it to create a Func and returns it:</p> <pre><code># We create a func from a block and assign it to foo\nfoo = func [3 + 4]\n# Now evaluating foo will give 7\nfoo\n</code></pre> <p>A Func evaluates the block when it's evaluated. This is in contrast to a Block which evaluates to itself. The return value of a Func is either the result of the last expression or you can return explicitly using the primitive return Func using the same character as in Smalltalk, <code>^</code>. Another important aspect of Funcs is that they are not polymorphic, or in other words, you can not overload them for different types of the arguments. However, several of the builtin core Funcs perform a bit of \"type testing\" internally so that you can indeed call them with different types of arguments and they handle them properly. For true polymorphic behaviors you should use (Polymethods](#Polymethods) in Spry.</p> <p>Funcs use prefix calling and they are called just like in Rebol:</p> <pre><code># Call foo with no arguments\nfoo\n\n# Call foo with one argument, an int\nfoo 4\n\n# Call foo with two arguments\nfoo 4 \"hey\"\n</code></pre> <p>Arguments to Funcs are \"pulled in\" using Arg words which are prefixed with <code>:</code>. Note that an arg word is an operation, not a declaration, so they can appear anywhere in the Func.</p> <pre><code># This func takes one argument and adds 4 to it\nfoo = func [:x + 4]\n# Prints 9 on stdout\necho foo 5\n</code></pre> <p>The Func <code>echo</code> is included in the VMModule <code>spryio</code> which in turn is included in the standard spry and ispry VMs. For embedded use one can however build a Spry VM that does not include it. <code>echo</code> is a prefix Func that takes one argument that it will turn into a string before writing it to stdout using Nim's echo proc.</p> <p>The arg word <code>:x</code> will take the next argument AST node (the <code>5</code> literal) to the <code>foo</code> Func, evaluate it at the call site (literals evaluate to themselves) and take the resulting node and store it in the local variable <code>x</code> in the Func closure, and the result of the arg word will be that node. Since the result is the value it means you can actually use <code>:x</code> in an expression just like we do above.</p> <p>Note</p> <p>The fact that arg words are operations also means the arity of a Func is not static, it could in theory pull in a different number of arguments - although that would be very confusing.</p> <p>You could also write the Func in \"Smalltalk style\" that looks like declarations:</p> <pre><code># This func takes one argument and adds 4 to it\nfoo = func [:x x + 4]\n# Prints 9 on stdout\necho foo 5\n</code></pre> <p>Currently that will be slightly slower since we first evaluate <code>:x</code> and then <code>x</code> but it may sometimes make the code easier to read.</p> <p>Arg words can also be \"get arg words\" which means that we can pull in the argument AST node without first evaluating it at the call site. Here is an example that shows the difference:</p> <pre><code>foo = func [:$x echo $x]\nbar = func [:x echo $x]\nx = \"abc\"\nbar x # prints \"abc\"\nfoo x # prints \"x\"\nbar (3 + 4) # prints \"7\"\nfoo (3 + 4) # prints \"(3 + 4)\"\n</code></pre> <p>The reason we use <code>echo $x</code> is to prevent <code>x</code> from being evaluated inside the func.</p>"},{"location":"manual.html#methods","title":"Methods","text":"<p>Methods are just like Funcs but they always take at least one argument, from the left. This mandatory \"receiver\" is accessible using the primitive func <code>self</code>, so no need to use an arg word to pull it in. This means Methods \"feel\" like OO messages, but they are still not polymorphic based on the receiver, again you should use Polymethods for that.</p> <pre><code># Call method foo on an int\n4 foo\n\n# Call method foo on a string, with one more argument\n\"hey\" foo 7\n\n# Call method foo with three arguments\n4 foo \"hey\" \"there\"\n</code></pre> <p>Methods are created using <code>method</code>:</p> <pre><code># Create a method that adds 5 to self\nplusfive = method [self + 5]\necho (3 plusfive) # prints \"8\"\n</code></pre> <p>Both methods and funcs can use keyword naming and calling style:</p> <pre><code># Create a function and assign it to a keyword\nadd:to: = func [:x + :y]\necho (add: 5 to: 6)   # prints \"11\"\n\n# And a method in the same way\nadd:and: = method [self + :x + :y]\necho (3 add: 5 and: 6) # prints \"14\"\n\n# Can also be called like this\necho (add:to: 5 6)    # prints \"11\"\necho (3 add:and: 5 6) # prints \"14\"\n</code></pre>"},{"location":"manual.html#scoping","title":"Scoping","text":"<p>Spry code is organized in nested Blocks. Each Block is a scope, a closure in fact. And each closure has a Map containing its local bindings, which you can reach explicitly using <code>locals</code>. The top level's local bindings are in fact <code>root</code>.</p> <p>Words are what you use to refer to things in Spry so if you use a regular eval word like <code>foo</code>, that means lookup the key \"foo\" first in the locals and then outwards until reaching the global scope. Then evaluate whatever value is returned from the lookup. In Spry we don't declare anything, not even local variables like you do in Smalltalk, instead we have 5 different variants of words to reach our bindings, here are all 5 described once more:</p> <pre><code># Lookup in locals and outwards to root and all Modules listed in modules, undef if not found\nfoo\n\n# Lookup outside this closure and outwards to root and all Modules listed in modules, undef if not found\n..foo\n\n# Lookup in the Map called Bar, undef if not found\nBar::foo\n\n# Lookup in self which is the nearest receiver Map\n@foo\n\n# Pull in the next argument to this Block invocation\n:foo\n</code></pre> <p>The first 4 variants can also be used as left side in an assignment with these meanings:</p> <pre><code># Bind in locals, regardless of any outer reachable foo's\nfoo = 5\n\n# Lookup outside this closure and outwards to root and all Modules listed in modules.\n# If found assign to that foo, otherwise bind in nearest outer closure.\n..foo = 5\n\n# Bind in the Map called Bar\nBar::foo = 5\n\n# Bind in self which is the nearest receiver Map\n@foo = 5\n</code></pre> <p>The most uncommon effect of these rules is that you often need to use <code>..foo</code> as left hand side in assignments being done inside control structure blocks. This is because all blocks are closures and we don't declare locals in Spry so Spry has no way of knowing that you want to assign to the outer <code>foo</code> and not a local <code>foo</code>. This means that the following code has to be rewritten to work as intended:</p> <pre><code>foo = func [ :a\n  x = 10\n  a &gt; 10 then: [x = 20] # This needs to say \"..x = 20\"\n  ^x]\n\necho foo 5  # prints 10\necho foo 12 # still prints 10!\n</code></pre> <p>The reason is that <code>x = 20</code> sets <code>x</code> in the local then-block, not in the outer func block. Rewriting with <code>..x</code> solves it, but we can perhaps do this instead:</p> <pre><code>foo = func [ :a\n  x = (a &gt; 10 then: [20] else: [10])\n  ^x]\n\necho foo 5  # prints 10\necho foo 12 # prints 20\n</code></pre> <p>Or even shorter of course:</p> <pre><code>foo = func [:a &gt; 10 then: [20] else: [10]]\n\necho foo 5  # prints 10\necho foo 12 # prints 20\n</code></pre> <p>For the moment this is a \"language wart\" - in other words - something I would like to fix but not sure exactly how yet. :)</p> <p>Note</p> <p>The rules for the left side in assignments are under evaluation. A variant could be that we distinguish between func/method/curly scopes and other blocks.</p>"},{"location":"manual.html#standard-library","title":"Standard Library","text":"<p>The Spry VM includes a very minimal \"standard library\" in the form of primitive Methods and Funcs, a few Spry only Methods and Funcs and a few singleton nodes. The VM creates the global <code>root</code> Map and populates it with words.</p> <p>The regular Spry VM <code>spry</code> and the REPL <code>ispry</code> also loads several VM Modules that adds more words to <code>root</code>. Finally, the file <code>spry.sy</code> is loaded with additional Spry library code that are not primitives.</p>"},{"location":"manual.html#singletons","title":"Singletons","text":"<p>The following singleton nodes are created and bound to these words by the VM.</p> Word Comment <code>false</code> Reference to the singleton for falsehood <code>true</code> Reference to the singleton for truth <code>undef</code> Reference to the singleton for missing value <code>nil</code> Reference to the singleton for value meaning no value <code>modules</code> Reference to a Block of Maps for lookups"},{"location":"manual.html#reflection","title":"Reflection","text":"<p>The following Funcs and Methods are available for reflection purposes.</p> Word Type Comment <code>root</code> Func Returns the Map of global bindings <code>activation</code> Func Returns the current Activation <code>locals</code> Func Returns the Map of local bindings <code>self</code> Func Returns the receiver in a Method, undef in a Func <code>node</code> Func Returns the receiver in a Method, unevaluated <code>;</code> Func Returns the previous receiver, enables Smalltalk style cascades <code>type</code> Method Returns a literal word representing the nodetype, see below. <p>The method <code>type</code> returns a literal word representing the type of the receiver node: <code>'int</code>, <code>'float</code>, <code>'string</code>,<code>'boolean</code>, <code>'undefined</code>, <code>'novalue</code>, <code>'block</code>, <code>'paren</code>, <code>'curly</code>, <code>'map</code>, <code>'binding</code>, <code>'evalword</code>, <code>'evalmoduleword</code>, <code>'evalselfword</code>, <code>'evalouterword</code>, <code>'evalargword</code>, <code>'getword</code>, <code>'getmoduleword</code>, <code>'getselfword</code>, <code>'getouterword</code>, <code>'getargword</code>, <code>'litword</code></p> <p>Note</p> <p>The Activation node does not yet expose any functionality, but it will eventually be used to open up access to the execution stack etc similar to <code>thisContext</code> in Smalltalk. The reason for <code>root</code> to not be a reference to the singleton is to avoid a recursive global Map.</p>"},{"location":"manual.html#creating-things","title":"Creating things","text":"<p>Spry is not a class based language. Things are created either using literal syntax (created at parse time), through specific evaluation mechanisms (maps are created through evaluating curlys) or through cloning already existing things:</p> <pre><code># Literal syntax, created at parse time\nx = \"abc\"\ny = 12.0\nz = 99\n\n# Composites, created at parse time\n# $ prevents evaluation so that we can hold the paren/curly itself\nparen = $ (1 + 3)\ncurly = $ {1 2 3}\n# No need for $ since blocks evaluate to themselves\nblock = [1 2 3]\n\n# Create a map through evaluating a curly\n# The curly is created at parse time, but the map\n# is created when we evaluate the curly\nmap = {x = 12}\n\n# Cloning at evaluation time, note need for parens\nx = (\"abc\" clone)\ny = ([1 2 3] clone)\nz = ({x = 12} clone)\n</code></pre> Word Type Comment <code>clone</code> Method Performs a copy of strings, does nothing for floats and ints and a performs a shallow copy of blocks, parens, curlys and maps."},{"location":"manual.html#tags","title":"Tags","text":"<p>All nodes of all types in Spry can have a block of tags. Tags are currently limited to being literal words. It's used mainly for Maps and Polymethods which forms the basis of OO in Spry.</p> Word Type Comment <code>x tag: aWord</code> Method Add a tag on a node x. If aWord is not a literal word, it will be converted to one <code>x tag? aWord</code> Method Check if a node x has the given tag. If aWord is not a literal word, it will be converted to one <code>x tags</code> Method Returns the Block of tags on node x <code>x tags: aBlock</code> Method Set the Block of tags on node x"},{"location":"manual.html#assignments","title":"Assignments","text":"<p>In Spry we don't have Rebol style \"set words\", instead we have a word <code>=</code> that is bound to a primitive Method that performs assignment. This method uses the left hand side unevaluated, which means it works for most normal cases. For more advanced cases where you want to compute the left hand side you can use <code>set:</code> instead. Similarly <code>?</code> has a counterpart in <code>get?</code>.</p> <p>Finally there is no unset word, but you can instead assign to <code>undef</code> which will remove the binding.</p> <p>Currently there is a language wart that usually forces assignments to be written with parentheses. Spry has no statement separators and does not consider line breaks. You can write a Spry program in one single long line. This means Spry has no simple of knowing when the expression ends. Due to this the current rule is that assignment only consumes a single node from the right.</p> <pre><code># You need a paren here because otherwise\n# Spry finds \"3\" and evaluates it (to 3 obviously)\n# and then assigns that to x.\nx = (3 + 4)\n\n# This works because readFile is a func and when\n# evaluated it will pull in the argument filename \nx = readFile \"afile.txt\"\n</code></pre> <p>One idea to improve this without introducing separators or making line breaks meaningful (I don't want to do any of those two) is to make evaluation more \"eager\". Using \"look ahead\" Spry could check if the word coming after \"3\" is in fact a method, and then it would continue evaluating it.</p> Word Type Comment <code>x = aNode</code> Method Assigns the right hand node to the left hand word x. Left hand side is not evaluated. It can be a literal word or a regular word for local binding. An outer word for binding to an outer closure, or a module word for binding in a Map or Module. <code>x ?</code> Method Checks if x is bound to something. Left hand side is not evaluated. It can be any kind of word, including a literal word. <code>x set: aNode</code> Method Assigns the right hand node to the left hand literal word. Left hand side is evaluated and should evaluate to a word which is used through the same rules as <code>=</code>. <code>x set?</code> Method Checks if x is bound to something. Left hand side is evaluated and should evaluate to a word."},{"location":"manual.html#arithmetic","title":"Arithmetic","text":"<p>Spry has int and float as numeric nodes and will automatically convert from int to float if they are mixed.</p> Word Type Comment <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> Method Normal arithmetic methods, ints are converted to floats if needed"},{"location":"manual.html#comparisons","title":"Comparisons","text":"Word Type Comment <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> Method Defined so far for int, float and strings"},{"location":"manual.html#equality","title":"Equality","text":"<p>In Spry <code>=</code> is used for assignment so we use <code>==</code> (and <code>!=</code>) for testing equality and <code>===</code> for testing identity.</p> Word Type Comment <code>==</code> Method Check equality <code>===</code> Method Check identity <code>!=</code> Method Checks for inequality <code>!===</code> Method Checks for non identity"},{"location":"manual.html#booleans_1","title":"Booleans","text":"Word Type Comment <code>not</code> Method Negates a boolean <code>and</code> Method If left hand side expression evaluates to true, then right hand side is also evaluated. True if both are true, otherwise false <code>or</code> Method If left hand side expression evaluates to false, then right hand side is also evaluated. True if either is true, otherwise false"},{"location":"manual.html#concatenation","title":"Concatenation","text":"Word Type Comment <code>,</code> Method Concatenates strings, blocks, parens and curlys"},{"location":"manual.html#conversions","title":"Conversions","text":"Word Type Comment <code>print</code> Method Returns the node in the user friendly string format for presentation (like Rebol's \"form\") <code>parse</code> Func Parse a string of Spry into nodes, comments are kept <code>serialize</code> Method Returns the node as a string in source form excluding comments <code>commented</code> Method Returns the node as a string in source form including comments <code>asFloat</code> Method Converts an int to float <code>asInt</code> Method Converts a float to int"},{"location":"manual.html#composites_1","title":"Composites","text":"<p>These methods operate mainly on the sequential composites - blocks, parens and curlys. Some also work for strings. And some also work for maps.</p> Word Type Comment <code>size</code> Method Returns number of elements, works for string, blocks, parens, curlys and maps. <code>at:</code> Method Get element at a key, works for blocks, parens, curlys and maps. Returns undef if not found. <code>at:put:</code> Method Set element at a key to a value, works for blocks, parens, curlys and maps. Using <code>undef</code> as value means removing the binding for Maps. <code>get:</code> Method Get element at unevaluated argument. Works for blocks, parens, curlys and maps. Returns undef if not found. <code>set:to:</code> Method Set element at unevaluated argument. Works for blocks, parens, curlys and maps. Using <code>undef</code> as value means removing the binding for Maps. <code>add:</code> Method Add element to sequential composite. Works for blocks, parens and curlys. <code>removeLast</code> Method Remove last element of sequential composite. Works for blocks, parens and curlys. <code>copyFrom:to:</code> Method Copy a sub range to form a new composite of the same type. Works for blocks, parens and curlys. <code>contains:</code> Method Test if the composite contains any element equal to the given argument. Works for blocks, parens, curlys and maps. <code>first</code> Method Return element at position 0. <code>second</code> Method Return element at position 1. <code>third</code> Method Return element at position 2. <code>fourth</code> Method Return element at position 3. <code>fifth</code> Method Return element at position 4. <code>last</code> Method Return last element. <code>do:</code> Method Iterate over block, paren or curly and evaluate argument block for each element, Smalltalk style. <code>sum</code> Method Sums all elements of a block, paren or curly. Can contain a mix of ints and floats. If all are int result will be an int. <p>For Maps you can also use <code>::</code>-syntax to get and together with <code>=</code> to set. Using <code>undef</code> as value means removing the binding for Maps.</p>"},{"location":"manual.html#blocks","title":"Blocks","text":"<p>Blocks actually double as positionable streams too, with an internal position just like in Rebol. This means we can easily step through a Block using its internal position. The following methods form the base of this stream protocol.</p> Word Type Comment <code>reset</code> Method Set position to 0 <code>pos</code> Method Get current position, first position is 0 <code>pos:</code> Method Set current position <code>read</code> Method Get the element at the current position without moving forward <code>write:</code> Method Set the element at the current position without moving forward <code>next</code> Method Get the element at the current position and increase the position <code>prev</code> Method Get the element at the current position and decrease the position <code>end?</code> Method Return true if position is &gt;= size, which indicates we have reached the end"},{"location":"manual.html#funcs-and-methods","title":"Funcs and Methods","text":"<p>The core unit of behavior in Spry is funcs and methods. As described above, both work essentially the same, but methods take the first argument (the \"receiver\") from the left and make it accessible using <code>self</code>, you don't use an arg word to pull it in. You use <code>^</code> to do an early return, just like in Smalltalk.</p> Word Type Comment <code>func</code> Func Creates a func which is a prefix function taking all arguments on the right side <code>method</code> Func Creates a method which is an infix function taking the first argument, the receiver, on the left side"},{"location":"manual.html#evaluation","title":"Evaluation","text":"<p>The following funcs performs explicit evaluation in various ways.</p> Word Type Comment <code>do</code> Func Takes one argument, a block. Evaluates the block. <code>$</code> Func Takes one argument but does not evaluate it, returns it unevaluated. Can be used to prevent evaluation of nodes. <code>eva</code> Func Takes one argument, evaluates it and returns the result. <code>eval</code> Func Takes one argument, evaluates it and then also evaluates the result. <code>^</code> Func Takes one argument, evaluates it and performs an early return."},{"location":"manual.html#words_1","title":"Words","text":"<p>Spry has 11 different kinds of Words. The following funcs can create and convert words in different ways.</p> Word Type Comment <code>reify</code> Func Makes a word from a literal word <code>litify</code> Func Makes a literal word from a word <code>quote</code> Func Makes a literal word from an unevaluated word <code>litword</code> Func Makes a literal word from a string <code>word</code> Func Makes a word from a string"},{"location":"manual.html#conditionals","title":"Conditionals","text":"<p>Spry uses Smalltalk style keyword based conditionals but I decided to rename the Smalltalk variants <code>ifTrue:</code>, <code>ifFalse:</code>, <code>ifTrue:ifFalse:</code>, <code>ifFalse:ifTrue:</code> to the slightly shorter <code>then:</code>, <code>else:</code>, <code>then:else:</code>, <code>else:then:</code>. </p> Word Type Comment <code>then:</code> Method If receiver is true then evaluate the given block <code>else:</code> Method If receiver is false then evaluate the given block <code>then:else:</code> Method If receiver is true then evaluate the first block, otherwise the second <code>else:then:</code> Method If receiver is false then evaluate the first block, otherwise the second <p>Other variants can easily be implemented in Spry too, like for example implementing <code>ifTrue:</code>, using <code>then:</code>. Pointless of course:</p> <pre><code>ifTrue: = method [:blk self then: [^do blk] nil]\n3 &lt; 4 ifTrue: [echo \"Works\"] \n</code></pre> <p>Or you could of course just make an alias, assigning <code>ifTrue:</code> to the same primitive as <code>then:</code> is bound to.</p> <pre><code>ifTrue: = $then:\n3 &lt; 4 ifTrue: [echo \"Works\"]\n</code></pre>"},{"location":"manual.html#loops","title":"Loops","text":"<p>The following loop words are also designed like in Smalltalk. </p> Word Type Comment <code>timesRepeat:</code> Method Smalltalk style loop. The receiver is an int and the argument is a block to evaluate that number of times <code>to:do:</code> Method Smalltalk style for-loop, although currently limited to a step by +1 <code>whileTrue:</code> Method Smalltalk style conditional loop <code>whileFalse:</code> Method Smalltalk style conditional loop"},{"location":"manual.html#misc","title":"Misc","text":"Word Type Comment <code>quit</code> Func Quits the interpreter. Takes one argument, the numeric exit code to return to the OS"},{"location":"manual.html#polymethod","title":"Polymethod","text":""},{"location":"manual.html#spry-library","title":"Spry library","text":"Word Type Comment error assert obect module sprydo: detect: select:"},{"location":"manual.html#modules","title":"Modules","text":"<p>Modules in Spry are simply Maps with an additional entry under the key <code>_meta</code> with a Map containing the meta information about the Module. Here is an example:</p> <pre><code>{\n  _meta = {\n    name = 'Foo\n    version = \"1.0\"\n    description = \"Testing module closure\"\n  }\n\n  # Local baz. The Map itself is the lexical parent of the funcs we create below.\n  # That means that lookups inside the funcs will continue outwards through the Map. \n  baz = 1\n\n  # Here we rely on a baz in this module, or else in the global scope\n  bar = func [:x + baz]\n\n  # Here we make sure to use the module baz, avoiding the local one inside the func\n  bar2 = func [ baz = 99 :x + ..baz]\n\n  # Here we use Foo::baz, which will resolve to 1 if this module is indeed loaded as Foo\n  bar3 = func [:x + Foo::baz]\n}\n</code></pre> <p>As we can see the above is just Spry syntax for a Map and the Map contains 3 funcs and one \"variable\" called <code>baz</code>. If we put this in <code>foo.sy</code> - the filename is not important and can be anything - we can then load this module into Spry using <code>loadFile: \"foo.sy\"</code>. The default behavior is to load and bind the module to the name in <code>_meta</code> as a global in <code>root</code>. Then we can manipulate it and reach it's members using <code>Foo::xxx</code> syntax:</p> <pre><code># Load the module as the name it has in the neta information\nloadFile: \"foo.sy\"\n\n# We can now access stuff in Foo, should print 1\necho Foo::baz\n\n# Run the bar func with 1 as argument, should print 2\necho Foo::bar 1\n\n# Set a global value for baz\nbaz = 10\n\n# This should return 2\necho Foo::bar2 1\n\n# And this should return 2\necho Foo::bar3 1\n\n# If we throw away Foo and load it as Zoo\nFoo = undef\nloadFile: \"foo.sy\" as: 'Zoo\n\n# Then all works the same, should print 2\necho Zoo::bar 1\n\n# Create a different Foo, so that bar3 finds something\nFoo = {baz = 8}\n\n# Should print 9\necho Zoo::bar3 1\n</code></pre> <p>Finally, we can also add modules to the special block called <code>modules</code> which is used by the lookup machinery in Spry. Lookups go outwards lexically all the way up to <code>root</code> and if it fails Spry then looks in each module listed in <code>modules</code> until giving up and returning <code>undef</code>.</p>"},{"location":"manual.html#vm-modules","title":"VM Modules","text":"<p>Core Spry comes with a bunch of assorted VM modules. A VM module is a separate Nim package that has a Nim proc that \"adds it\" to a Spry Interpreter instance. The idea is that when you build a Spry VM you pick which VM modules you want to include and then call them one by one. The standard Spry VM has a section that looks something like this:</p> <pre><code>import spryextend, sprymath, spryos, spryio, sprythread,\nspryoo, sprydebug, sprycompress, sprystring, sprymodules,\nspryreflect, spryui\n\nvar spry = newInterpreter()\n\n# Add extra modules\nspry.addExtend()\nspry.addMath()\nspry.addOS()\nspry.addIO()\nspry.addThread()\nspry.addOO()\nspry.addDebug()\nspry.addCompress()\nspry.addString()\nspry.addModules()\nspry.addReflect()\nspry.addUI()\n</code></pre> <p>Here we see that the regular VM imports a bunch of VM modules at the top, and then calls <code>addXXX</code> for each one. Let's look closer at the LZ4 compression VM module called <code>sprycompress.nim</code>:</p> <pre><code>import lz4\nimport spryvm\n\n# Spry compression\nproc addCompress*(spry: Interpreter) =\n# Compression of string\nnimFunc(\"compress\"):\nnewValue(compress(StringVal(evalArg(spry)).value, level=1))\nnimFunc(\"uncompress\"):\nnewValue(uncompress(StringVal(evalArg(spry)).value))\n</code></pre> <p>The name <code>addXXX</code> is just convention, but it must take an argument spry of type <code>aInterpreter</code>. Then in that proc we can do several things, but perhaps most importantly we can add primitives to Spry. We typically do that using the Nim templates <code>nimFunc</code> and <code>nimMeth</code>. A primitive is given a name and the code has access to the Interpreter via <code>spry</code>. Using Nim procs like <code>evalArg(spry)</code> we can pull in the next argument (<code>evalArgInfix(spry)</code> pulls in the receiver from the left) and at the end the primitive must return a <code>Node</code>. <code>newValue</code> will create the proper Node from a bunch of Nim types.</p> <p>The templates <code>nimFunc</code> and <code>nimMeth</code> will then create a NimFunc (or NimMeth) node and bind it to the name given in the Spry <code>root</code> Map.</p> <p>By looking at the various VM modules you can easily see how to make your own! It's easy.</p>"},{"location":"manual.html#spry-grammar","title":"Spry grammar","text":"<p>Here is a very informal extended BNF of Spry (as of now) written using similar conventions that Nim does. I think it's fairly correct - however - the current parser in Spry is a handwritten iterative (not recursive) parser so some parts were hard to express, like rules for comments and whitespace, see the notes in the BNF for details.</p> <p>In this EBNF <code>(a)*</code> means 0 or more a's, <code>a+</code> means 1 or more a's, and <code>(a)?</code> means an optional a. Parentheses may be used to group elements. <code>{}</code> are used to describe character sets. Stuff I can't figure out is described inside <code>{{ }}</code> using plain english.</p> <p>Note that <code>true, false, nil, undef</code> and all control structures are expressed using words, so these 26 lines are actually the complete grammar!</p> <pre><code># Ints are parsed using Nim parseInt, floats using parseFloat and strings using unescape.\n# This means they follow the following grammar.\nint = ['+' | '-'] digit (['_'] digit)*\nexponent = ('e' | 'E') ['+' | '-'] digit (['_'] digit)*\nfloat = ['+' | '-'] digit (['_'] digit)* (('.' (['_'] digit)* [exponent]) | exponent)\n\n# Inside the string we replace any \\\\ by \\, any \\' by ', any \\\" by \" and any\n# \\xHH (where HH is a hexadecimal value) with the corresponding character\nstring = '\"' {{all sequences of characters except a \\\" not preceded by a \\\\}} '\"'\n\n# Literals are pluggable in the Parser, but these three are the core ones\nliteral = int | float | string\n\n# Same definition as in Nim strutils, whitespace separates words in Spry\nwhitespace = {' ', '\\x09', '\\x0B', '\\x0D', '\\x0A', '\\x0C'}\n\n# Note that there is a set of special characters that can only form\n# names together with other special characters.\nname = {{any sequence of characters not parsed as a literal}}\n\nqualifiedname = name '::' name\n\nevalnormalword = (name | qualifiedname)\nevalselfword = '@' name\nevalouterword = '..' name\n\nevalword = evalouterword | evalselfword | evalnormalword\n\ngetnormalword = '$' (name | qualifiedname)\ngetselfword = '$@' name\ngetouterword = '$..' name\n\ngetword = getouterword | getselfword | getnormalword\n\nargevalword = ':' name\narggetword =  ':$' name\n\nargword = argevalword | arggetword\n\nword = evalword | getword | argword\n\nblock = '[' program ']'\nparen = '(' program ')'\ncurly = '{' program '}'\n\n# Comments are detected outside literals and consume the rest of the line\n# They do NOT constitute nodes in Spry. Yet.\ncomment = '#' (any)* '\\l'\n\nnode = literal | word | block | paren | curly\n\n# A program is just a sequence of nodes separated by optional whitespace.\n# Perhaps not exactly correct, two words in sequence *must* be separated by whitespace.\nprogram = ((whitespace)? node (whitespace)?)*\n</code></pre>"},{"location":"news.html","title":"News","text":""},{"location":"news.html#refreshed-web-site","title":"Refreshed web site","text":"<p>2020-06-02</p> <p>Refreshed web site with new theme for MkDocs and fixed the web site REPL.</p>"},{"location":"news.html#discord-server","title":"Discord server","text":"<p>2019-07-30</p> <p>I really like Discord for most of my chat needs these days, so I created a Spry server - join in!</p>"},{"location":"news.html#new-top-level-domain","title":"New Top Level Domain","text":"<p>2018-06-04</p> <p>For various reasons Spry now lives at Sprylang.se.</p>"},{"location":"news.html#created-google-group","title":"Created Google Group","text":"<p>2016-08-29</p> <p>A mailinglist forum is great for a programming language IMHO, we have gitter but for more lengthy \"out-of-band\" discussions I prefer a list. Here it is: https://groups.google.com/forum/#!forum/sprylang</p>"},{"location":"news.html#benchmarking-spry-vs-squeak-51","title":"Benchmarking Spry vs Squeak 5.1","text":"<p>2016-08-26</p> <p>I posted an article on my blog about some small benchmark snippets that I tried in both Squeak 5.1 and current Spry. Back in may I also wrote another article looking at other performance aspects.</p> <p>I have also started an article on this site comparing Spry and Smalltalk.</p>"},{"location":"news.html#is-spry-a-smalltalk","title":"Is Spry a Smalltalk?","text":"<p>2016-07-19</p> <p>I posted an article on my blog exploring what Smalltalk is and if Spry qualifies as one.</p>"},{"location":"repl.html","title":"Spry JavaScript REPL","text":"<p>On this page we have the Spry interpreter compiled, together with 10 extra VM modules (core, debug, extend, math, OO, string, modules, reflect, block and browser) and minified to about 157kb ugly js. You can find this in github.</p> <p>You can enter code and eval below, output is appended below the code area. Code is evaluated in the same interpreter so assignments are kept between evaluations.</p> <p>Here are just some examples:</p> <pre><code># Spry is homoiconic\ncode = [3 + 4]\ncode at: 0 put: 8\ndo code\n</code></pre> <pre><code># Let's add a method to:do: that works as in Smalltalk.\n# Methods take the first argument, the \"receiver\", from the left\n# and binds it to \"self\". Note second assignment is a \"reassignment\"\n# so that we for sure assign the outer n and not a new local n.\n# This already exists implemented as a native.\nto:do: = method [:to :block\n  n = self\n  [n &lt;= to] whileTrue: [\n    do block n\n    n := (n + 1)]]\n\n# Then we can loop in Smalltalk style echoing 1 to 5!\n1 to: 5 do: [echo :x]\n</code></pre> <pre><code># We can similarly implement select: from Smalltalk.\n# This already exists implemented as a native, but anyway.\nselect: = method [:pred\n  result = clone []\n  self reset\n  [self end?] whileFalse: [\n    n = (self next)\n    do pred n then: [result add: n]]\n  ^result]\n\n# Then use it to produce [3 4]\n[1 2 3 4] select: [:x &gt; 2]\n</code></pre> <p>Enter Spry code:</p> <p>\"3 + 4 = \", ((3 + 4) print)</p> <p>Eval (ctrl-enter)</p> <p></p>"},{"location":"spry-vs-smalltalk.html","title":"Spry vs Smalltalk","text":"<p>Spry is a functional language with OO mechanisms and syntax that makes it feel very close to Smalltalk.</p> <p>Let's translate a few snippets of Smalltalk code to Spry.</p> <p>Smalltalk:</p> <pre><code>| a b |\na := 5.\nb := a + 1.\n^b\n</code></pre> <p>Spry:</p> <pre><code>a = 5\nb = (a + 1)\n^b\n</code></pre> <ul> <li>In Spry we don't declare locals, in fact, there are no declarations of variables anywhere.</li> <li>Assignment uses <code>=</code> and there are no statement separators. The lack of statement separators also mean that we need to use parentheses sometimes to make sure the right hand side of the assignment is a single expression.</li> <li>Return behaves and looks the same using <code>^</code>.</li> </ul> Smalltalk Spry Comment <code>\"a comment\"</code> <code># a comment</code> <code>'abc'</code> <code>\"abc\"</code> <code>$x</code> Spry does not have Characters yet. <code>#foo</code> <code>'foo</code> Symbols are called Literal Words <code>#(1 2 3)</code> <code>[1 2 3]</code> <code>x := 3 + 4.</code> <code>x = (3 + 4)</code> In Spry parentheses are needed since there are no statement separators. <code>[:x | x + 1]</code> <code>[:x + 1]</code> In Spry <code>:x</code> is an operation, not a declaration. <code>OrderedCollection with: 1 with: 2</code> <code>[1 2]</code> Spry blocks are used for all sequences. <code>MyClass new</code> <code>object [MyClass] {}</code> <code>{1 + 2. 2 + 3}</code> <code>reduce [(1 + 2) (2 + 3)]</code>"},{"location":"start.html","title":"Getting Started","text":"<p>There are several ways to get Spry running, and there are several ways to use and run Spry.</p>"},{"location":"start.html#repl","title":"REPL","text":"<p>Absolutely most trivial way is to use the REPL web page here in this site. That's an actual Spry interpreter compiled to javascript. But this is just a toy.</p>"},{"location":"start.html#windows","title":"Windows","text":"<p>Windows is a ... messy platform. On Linux or OSX it's very easy to build Spry yourself (see below) but on Windows it's a bit more complicated. I have put together a trivial zip file with binaries if you just want to try it out:</p> <ul> <li>http://files.krampe.se/spry/spry-0.8.0-win32.zip</li> </ul> <p>Just download and unzip somewhere and double click on ispry.exe to get into the REPL VM. Or pull up a command prompt, cd into this directory and run spry.exe together with a script, for example like this:</p> <pre><code>spry hello.sy\n</code></pre> <p>The included files with the sy-extension are just plain text files you can edit and run this way.</p>"},{"location":"start.html#linux-and-osx","title":"Linux and OSX","text":"<p>If you want to start fiddling more seriously with Spry you would want to clone it from github and build it yourself. It's quite easy, just follow the instructions on github.</p>"},{"location":"taste.html","title":"Tasting Spry","text":"<p>The following shows some simple examples of Spry code, just to get a feeling for it.</p> <p>TO BE WRITTEN</p>"}]}